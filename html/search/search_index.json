{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Interactive Population Density Visualization Overview This project creates an interactive 2.5D visualization of global population densities using deck.gl. Population density is represented through both height and color saturation, making demographic patterns easily recognizable. The web application allows users to explore population data from global to regional scales. Prerequisites Python 3.x Node.js Mapbox access token Download the demographic dataset from SEDAC CIESIN Select: DIRECT DOWNLOAD Files: All Temporal: Combined Five Year Age Groups Format: NetCDF Resolution: 2.5 Minute Setup Instructions Data Loading (once) Data preparation: Unzip the downloaded dataset Move gpw_v4_basic_demographic_characteristics_rev11_mt_2010_dens_2pt5_min.nc to the /data folder Run the data loading notebook: Navigate into /src/backend/notebooks cd /src/backend/notebooks python3 -m venv venv source venv/bin/activate Install dependencies: pip install -r requirements.txt Run Notekook to create the database quadkeyDB.sqlite in /data jupyter notebook loadDataSQLite.ipynb Backend Setup Navigate into src/backend/fastAPI cd src/backend/fastAPI Create and activate Python virtual environment: python3 -m venv venv source venv/bin/activate Install dependencies: pip install -r requirements.txt Start the backend server: fastapi dev mainSqlite.py Frontend Setup Navigate to the frontend folder (/src/frontend/deckgl) and install dependencies: npm install Configure Mapbox token (choose one method): # Option 1: Environment variable export MapboxAccessToken=<your_mapbox_token> # Option 2: Direct configuration in app.tsx # Set MAPBOX_TOKEN in the source code Start the development server: npm start","title":"Interactive Population Density Visualization"},{"location":"#interactive-population-density-visualization","text":"","title":"Interactive Population Density Visualization"},{"location":"#overview","text":"This project creates an interactive 2.5D visualization of global population densities using deck.gl. Population density is represented through both height and color saturation, making demographic patterns easily recognizable. The web application allows users to explore population data from global to regional scales.","title":"Overview"},{"location":"#prerequisites","text":"Python 3.x Node.js Mapbox access token Download the demographic dataset from SEDAC CIESIN Select: DIRECT DOWNLOAD Files: All Temporal: Combined Five Year Age Groups Format: NetCDF Resolution: 2.5 Minute","title":"Prerequisites"},{"location":"#setup-instructions","text":"","title":"Setup Instructions"},{"location":"#data-loading-once","text":"Data preparation: Unzip the downloaded dataset Move gpw_v4_basic_demographic_characteristics_rev11_mt_2010_dens_2pt5_min.nc to the /data folder Run the data loading notebook: Navigate into /src/backend/notebooks cd /src/backend/notebooks python3 -m venv venv source venv/bin/activate Install dependencies: pip install -r requirements.txt Run Notekook to create the database quadkeyDB.sqlite in /data jupyter notebook loadDataSQLite.ipynb","title":"Data Loading (once)"},{"location":"#backend-setup","text":"Navigate into src/backend/fastAPI cd src/backend/fastAPI Create and activate Python virtual environment: python3 -m venv venv source venv/bin/activate Install dependencies: pip install -r requirements.txt Start the backend server: fastapi dev mainSqlite.py","title":"Backend Setup"},{"location":"#frontend-setup","text":"Navigate to the frontend folder (/src/frontend/deckgl) and install dependencies: npm install Configure Mapbox token (choose one method): # Option 1: Environment variable export MapboxAccessToken=<your_mapbox_token> # Option 2: Direct configuration in app.tsx # Set MAPBOX_TOKEN in the source code Start the development server: npm start","title":"Frontend Setup"},{"location":"backend/","text":"FastAPI Backend Overview This project provides a lightweight backend service using FastAPI, which serves geospatial data stored in a SQLite database. Key features include: - Retrieval of tile data using quadkeys. - Detail-level control for granular queries. - Database schema inspection. Technology Stack Backend: FastAPI Database: SQLite API Endpoints /api/male/{z}/{y}/{x}/{raster_index}/{detailLevel}/{heightLevel}/{maxValue} Fetch tile data for a specific area. Parameters: z (int): Zoom level y (int): Tile Y-coordinate x (int): Tile X-coordinate raster_index (int): Raster index for database query detailLevel (int): Depth of children quadkeys Response: JSON object with quadkey and corresponding data values. /api/schema Retrieve the database schema. Response: List of table names in the SQLite database. Key Components Middleware A middleware logs the time taken for each request to help monitor performance. Database Interaction The lifespan manager initializes a connection to the SQLite database and safely closes it when the app shuts down. Quadkey Usage The application uses pyquadkey2 to generate quadkeys and fetch detailed tile data.","title":"FastAPI Backend"},{"location":"backend/#fastapi-backend","text":"","title":"FastAPI Backend"},{"location":"backend/#overview","text":"This project provides a lightweight backend service using FastAPI, which serves geospatial data stored in a SQLite database. Key features include: - Retrieval of tile data using quadkeys. - Detail-level control for granular queries. - Database schema inspection.","title":"Overview"},{"location":"backend/#technology-stack","text":"Backend: FastAPI Database: SQLite","title":"Technology Stack"},{"location":"backend/#api-endpoints","text":"","title":"API Endpoints"},{"location":"backend/#apimalezyxraster_indexdetaillevelheightlevelmaxvalue","text":"Fetch tile data for a specific area. Parameters: z (int): Zoom level y (int): Tile Y-coordinate x (int): Tile X-coordinate raster_index (int): Raster index for database query detailLevel (int): Depth of children quadkeys Response: JSON object with quadkey and corresponding data values.","title":"/api/male/{z}/{y}/{x}/{raster_index}/{detailLevel}/{heightLevel}/{maxValue}"},{"location":"backend/#apischema","text":"Retrieve the database schema. Response: List of table names in the SQLite database.","title":"/api/schema"},{"location":"backend/#key-components","text":"","title":"Key Components"},{"location":"backend/#middleware","text":"A middleware logs the time taken for each request to help monitor performance.","title":"Middleware"},{"location":"backend/#database-interaction","text":"The lifespan manager initializes a connection to the SQLite database and safely closes it when the app shuts down.","title":"Database Interaction"},{"location":"backend/#quadkey-usage","text":"The application uses pyquadkey2 to generate quadkeys and fetch detailed tile data.","title":"Quadkey Usage"},{"location":"frontend/","text":"Frontend Overview This React TypeScript application visualizes geospatial data using a Mapbox and Deck.gl integration. The application allows users to: Visualize raster data on a map. Adjust visualization parameters dynamically, including raster selection, color value normalization, detail level, height scaling, and opacity. Technology Stack Frontend Framework: React with TypeScript Map Visualization: Mapbox GL and Deck.gl Geospatial Layers: Deck.gl Geo-layers ( TileLayer and QuadkeyLayer ) Mapbox Mapbox is used as the base map provider to render map tiles and manage the overall map interface. Its key roles include: Base Map rendering and navigation control. Deck.gl is used to add custom and advanced layers on top of the Mapbox base map. The TileLayer is configured to fetch raster data dynamically from a backend API. The layer manages loading and rendering of tiles efficiently. The QuadkeyLayer visualizes geospatial data by mapping quadkeys to colors and elevations. Deck.gl allows layers to be updated dynamically by passing new props. Deck.gl is used like in this example: const tileLayerQkey = new TileLayer<DataType>({ data: [ `http://127.0.0.1:8000/api/male/{z}/{y}/{x}/${selectedRaster}/${detailLevel}/${heightLevel}/${maxValue}`, ], renderSubLayers: (props) => [ new QuadkeyLayer<DataType>({ data: props.data, getQuadkey: (d) => d.quadkey, getFillColor: (d) => { /* Map data values to colors */ }, getElevation: (d) => d.value, }), ], }); Color is set by binning the normalized data: getFillColor: (d) => { const normalizedValue = normalizer(d.value); const opacity = opacityGui; const colArr = [ [255, 255, 229, opacity], [255, 247, 188, opacity], [254, 227, 145, opacity], [254, 196, 79, opacity], [251, 154, 41, opacity], [236, 112, 20, opacity], [204, 76, 2, opacity], [153, 52, 4, opacity], [102, 37, 6, opacity] ]; const bin = Math.round(Math.min(normalizedValue * 8, 8)); return new Uint8ClampedArray(colArr[bin]); }, Using the Normalizer The maxValue can be set by the user const normalizer = (value: number) => { const min = 0; return (value - min) / (maxValue - min); };","title":"Frontend"},{"location":"frontend/#frontend","text":"","title":"Frontend"},{"location":"frontend/#overview","text":"This React TypeScript application visualizes geospatial data using a Mapbox and Deck.gl integration. The application allows users to: Visualize raster data on a map. Adjust visualization parameters dynamically, including raster selection, color value normalization, detail level, height scaling, and opacity.","title":"Overview"},{"location":"frontend/#technology-stack","text":"Frontend Framework: React with TypeScript Map Visualization: Mapbox GL and Deck.gl Geospatial Layers: Deck.gl Geo-layers ( TileLayer and QuadkeyLayer )","title":"Technology Stack"},{"location":"frontend/#mapbox","text":"Mapbox is used as the base map provider to render map tiles and manage the overall map interface. Its key roles include: Base Map rendering and navigation control.","title":"Mapbox"},{"location":"frontend/#deckgl","text":"is used to add custom and advanced layers on top of the Mapbox base map. The TileLayer is configured to fetch raster data dynamically from a backend API. The layer manages loading and rendering of tiles efficiently. The QuadkeyLayer visualizes geospatial data by mapping quadkeys to colors and elevations. Deck.gl allows layers to be updated dynamically by passing new props. Deck.gl is used like in this example: const tileLayerQkey = new TileLayer<DataType>({ data: [ `http://127.0.0.1:8000/api/male/{z}/{y}/{x}/${selectedRaster}/${detailLevel}/${heightLevel}/${maxValue}`, ], renderSubLayers: (props) => [ new QuadkeyLayer<DataType>({ data: props.data, getQuadkey: (d) => d.quadkey, getFillColor: (d) => { /* Map data values to colors */ }, getElevation: (d) => d.value, }), ], }); Color is set by binning the normalized data: getFillColor: (d) => { const normalizedValue = normalizer(d.value); const opacity = opacityGui; const colArr = [ [255, 255, 229, opacity], [255, 247, 188, opacity], [254, 227, 145, opacity], [254, 196, 79, opacity], [251, 154, 41, opacity], [236, 112, 20, opacity], [204, 76, 2, opacity], [153, 52, 4, opacity], [102, 37, 6, opacity] ]; const bin = Math.round(Math.min(normalizedValue * 8, 8)); return new Uint8ClampedArray(colArr[bin]); }, Using the Normalizer The maxValue can be set by the user const normalizer = (value: number) => { const min = 0; return (value - min) / (maxValue - min); };","title":"Deck.gl"}]}